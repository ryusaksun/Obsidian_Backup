JPEG 有损压缩是一个将无损和有损技术完美结合的经典流程。根据文件 `Shu-Zi-Tu-Xiang-Chu-Li-Di-Wu-Zhang-Tu-Xiang-Yu-Shi-Pin-Bian-Jie-Ma-Ya-Suo.pdf` 的内容，其完整步骤如下：

## 第一步：色彩空间转换与降采样（预处理）

- 转换：将图像从 RGB 空间转换到 YCbCr 空间。

    - Y：亮度（Luma），包含了图像的主要信息（黑白轮廓）。

    - Cb/Cr：色度（Chroma），代表颜色偏差。

- 降采样：由于<font color="#00b0f0">人眼对亮度敏感而对颜色不敏感</font>，JPEG 允许保留 Y 分量，<font color="#00b0f0">而对 Cb 和 Cr 分量进行"减半"或更激进的降采样（丢弃部分色度数据）</font>，这是第一层有损压缩。

## 第二步：分块与 DCT 变换（核心变换）

- 分块：将图像（Y、Cb、Cr 分量分别处理）切分为 $8 \times 8$ 的像素块。

- DCT 变换：对每个 $8 \times 8$ 块进行离散余弦变换。

    - 结果：产生 1 个 DC 系数（直流分量，代表平均亮度，位于左上角）和 63 个 AC 系数（交流分量，代表细节纹理）。

    - 目的：将空间域的像素值转换为频率域的系数，让能量集中在左上角。

## 第三步：量化（最关键的有损步骤）

这是 JPEG 压缩率高但画质损失的根本原因。

- 操作：用一个标准的量化表（Quantization Table）去"除"DCT 得到的系数矩阵，并取整。

    - 量化表的设计很讲究：左上角（低频）的除数小，保留精度高；右下角（高频）的除数大（如 100+），让商直接变成 0。

- 结果：经过量化后，右下角那一堆原本很小的高频系数，基本上都变成了 0。这大大减少了有效数据的数量。

## 第四步：Z 字形扫描与编码（无损打包）

这一步是为了把量化后的稀疏矩阵高效地存起来。

1. Zigzag 扫描：

    - 不按行也不按列读，而是按"之"字形路线扫描。

    - 目的：把矩阵左上角的非零数和右下角的零，重新排列成一维数组。这样所有的 0 就会聚在数组的末尾。

2. 分别编码：

    - <font color="#00b0f0">DC 系数（差分编码）</font>：由于相邻块的亮度很接近，使用 DPCM（预测编码），只记录当前块与上一个块 DC 值的差值。

    - <font color="#00b0f0">AC 系数（行程编码）</font>：对于那一长串的 0，使用 RLE（行程编码），比如记作"连续 15 个 0"。

3. 熵编码：最后，对上述编码生成的数据流进行霍夫曼编码（Huffman Coding），利用统计特性进一步压缩比特流。

## 总结

JPEG 压缩流程就像是"切块 $\rightarrow$ 变身（DCT） $\rightarrow$ 扔掉细节（量化） $\rightarrow$ 打包带走（编码）"。其中量化步骤决定了压缩后的画质好坏，而 DCT 和编码技术则保证了压缩的高效性。

## 补充

DCT 变换（离散余弦变换）在图像处理中（尤其是 JPEG 压缩标准中）的核心作用是将图像从空间域转换到频率域。这使得我们可以分离出图像中的低频信息（主要视觉内容）和高频信息（细节和噪声），从而进行针对性的压缩。

执行 DCT 变换通常不是直接对整张图像操作，而是分块进行的。以下是标准的 DCT 变换及后续处理步骤：

### 1. 图像分块 (Block Splitting)

为了降低计算复杂度并适应局部图像特征，首先将图像划分为 $N \times N$ 的像素块。

- 标准大小：在 JPEG 中，标准通常是 $8 \times 8$ 的子块。

- 原因：如果对整张图做 DCT，计算量过大且忽略了图像的局部相关性；块太小则去相关性效果不明显。

### 2. 零电平平移 (Level Offset / Zero-Shift)

对于 8 位灰度图像，像素值范围是 $[0, 255]$。

- 操作：将每个像素值减去 128（即 $2^7$）。

- 结果：像素值范围变为 $[-128, 127]$。

- 目的：使信号以 0 为中心，降低直流分量（DC）的幅度，不仅利用了余弦函数的对称性，也提高了后续编码的效率。

### 3. 执行前向 DCT 变换 (Forward DCT)

对每个 8×8 的像素块应用二维 DCT 公式。变换后得到一个 8×8 的系数矩阵。

- 计算结果：

    - DC 系数 (直流分量)：位于矩阵左上角 $(0,0)$ 处的系数。它代表了该 $8 \times 8$ 图像块的平均亮度（或者是减去 128 后的平均值）。DC 系数通常数值最大，包含了最重要的能量。

    - AC 系数 (交流分量)：剩余的 63 个系数。从左上角向右下角，频率逐渐升高。右下角的系数代表图像中的高频细节（如边缘、纹理的变化）。对于平滑图像，这些高频系数通常接近于 0。

### 4. 量化 (Quantization) —— 这是压缩的关键步骤

DCT 变换本身是无损的（除了计算精度误差），真正的"有损压缩"发生在这一步。

- 操作：利用一个预定义的量化表 (Quantization Table)，将 DCT 系数矩阵中的每个元素除以量化表中对应的元素，并将结果四舍五入取整。

    $$F_{Quantized}(u,v) = \text{round}\left( \frac{F(u,v)}{Q(u,v)} \right)$$

- 原理：

    - 人眼对低频信息敏感，对高频细节不敏感。

    - 因此，量化表中左上角（低频）的数值较小（保留精度），右下角（高频）的数值很大（粗略量化）。

- 结果：经过这一步，大量的高频 AC 系数会变成 0，这为后续的高效压缩打下了基础。

### 5. "Z" 字形扫描 (Zigzag Scan)

为了进行编码，需要将 8×8 的二维矩阵转换为一维数组。

- 路径：不按传统的"逐行"扫描，而是采用 Zigzag（Z 字形）顺序扫描。

- 顺序：从左上角 DC 系数开始，沿着对角线方向往复移动，最后到达右下角。

- 目的：由于量化后，非零系数集中在左上角，右下角大部分是连续的零。Zigzag 扫描能将非零系数聚集在数组前面，而将长串的零聚集在数组末尾，非常利于游程编码（RLE）。

### 6. 熵编码 (Entropy Coding)

最后，对一维化后的数据进行无损编码。

- DC 系数编码：相邻图像块的 DC 系数相关性很强（亮度通常变化不大），因此使用差分脉冲编码调制 (DPCM)，只存储当前块与前一块 DC 系数的差值。

- AC 系数编码：使用游程编码 (RLE)（记录连续 0 的个数）结合 Huffman 编码。

### 总结

整个流程可以概括为：

原图 $\rightarrow$ 分块 (8x8) $\rightarrow$ 减 128 $\rightarrow$ DCT 变换 $\rightarrow$ 量化 (丢弃高频) $\rightarrow$ Z 字扫描 $\rightarrow$ 编码

解码过程则是上述步骤的逆过程：解码 $\rightarrow$ 反 Z 字扫描 $\rightarrow$ 反量化 $\rightarrow$ IDCT (逆变换) $\rightarrow$ 加 128 $\rightarrow$ 拼合图像。

---

**<font color="#2ecc71">✅ 已格式化</font>**
