## 一.WF-VAE代码

### 1.3D 小波正变换
```python

class HaarWaveletTransform3D(nn.Module):


def __init__(self, *args, **kwargs) -> None:


super().__init__(*args, **kwargs)

# 8 个因果卷积层，核大小 2x2x2，步长 2，实现 2 倍下采样

# 因果卷积输入参数（in_channels, out_channels, kernel_size, padding, stride, bias）

# 8 个卷积层分别代表 8 种小波系数

self.h_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # LLL 低频

self.g_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # LLH 垂直边缘

self.hh_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # LHL 水平边缘

self.gh_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # LHH 对角线

self.h_v_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # HLL 时间变化

self.g_v_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # HLH

self.hh_v_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # HHL

self.gh_v_conv = CausalConv3d(1, 1, 2, padding=0, stride=2, bias=False) # HHH 高频细节


# 初始化小波滤波器权重为 Haar 小波核

self._initialize_weights()

  

def _initialize_weights(self):

# 定义 8 个 Haar 小波核

# h (LLL): 时间低频, 水平低频, 垂直低频 - 全+1

# 主要提取低频平滑信号

h = torch.tensor([[[1, 1], [1, 1]], [[1, 1], [1, 1]]]) * 0.3536

# g (LLH): 时间低频, 水平低频, 垂直高频 - 宽度交替

g = torch.tensor([[[1, -1], [1, -1]], [[1, -1], [1, -1]]]) * 0.3536

# hh (LHL): 时间低频, 水平高频, 垂直低频 - 高度交替

hh = torch.tensor([[[1, 1], [-1, -1]], [[1, 1], [-1, -1]]]) * 0.3536

# gh (LHH): 时间低频, 水平高频, 垂直高频 - 对角交替

# 主要检测对角线方向的边缘

gh = torch.tensor([[[1, -1], [-1, 1]], [[1, -1], [-1, 1]]]) * 0.3536

# h_v (HLL): 时间高频, 水平低频, 垂直低频 - 时间交替

h_v = torch.tensor([[[1, 1], [1, 1]], [[-1, -1], [-1, -1]]]) * 0.3536

# g_v (HLH): 时间高频, 水平低频, 垂直高频

g_v = torch.tensor([[[1, -1], [1, -1]], [[-1, 1], [-1, 1]]]) * 0.3536

# hh_v (HHL): 时间高频, 水平高频, 垂直低频

hh_v = torch.tensor([[[1, 1], [-1, -1]], [[-1, -1], [1, 1]]]) * 0.3536

# gh_v (HHH): 时间高频, 水平高频, 垂直高频 - 全交替

# 主要检测高频细节/噪声

gh_v = torch.tensor([[[1, -1], [-1, 1]], [[-1, 1], [1, -1]]]) * 0.3536

# 调整核形状为卷积权重格式: [out_channels, in_channels, D, H, W]

# [out_channels, in_channels, D, H, W]分别是输出通道数、输入通道数、深度、高度、宽度

h = h.view(1, 1, 2, 2, 2)

g = g.view(1, 1, 2, 2, 2)

hh = hh.view(1, 1, 2, 2, 2)

gh = gh.view(1, 1, 2, 2, 2)

h_v = h_v.view(1, 1, 2, 2, 2)

g_v = g_v.view(1, 1, 2, 2, 2)

hh_v = hh_v.view(1, 1, 2, 2, 2)

gh_v = gh_v.view(1, 1, 2, 2, 2)

# 将预定义权重复制到卷积层（不计算梯度）

# 将预定义的 Haar 小波核复制到 8 个因果卷积层的权重中，同时确保设备和数据类型兼容

with torch.no_grad():

self.h_conv.conv.weight.copy_(h.to(self.h_conv.conv.weight.device).to(self.h_conv.conv.weight.dtype))

self.g_conv.conv.weight.copy_(g.to(self.g_conv.conv.weight.device).to(self.g_conv.conv.weight.dtype))

self.hh_conv.conv.weight.copy_(hh.to(self.hh_conv.conv.weight.device).to(self.hh_conv.conv.weight.dtype))

self.gh_conv.conv.weight.copy_(gh.to(self.gh_conv.conv.weight.device).to(self.gh_conv.conv.weight.dtype))

self.h_v_conv.conv.weight.copy_(h_v.to(self.h_v_conv.conv.weight.device).to(self.h_v_conv.conv.weight.dtype))

self.g_v_conv.conv.weight.copy_(g_v.to(self.g_v_conv.conv.weight.device).to(self.g_v_conv.conv.weight.dtype))

self.hh_v_conv.conv.weight.copy_(hh_v.to(self.hh_v_conv.conv.weight.device).to(self.hh_v_conv.conv.weight.dtype))

self.gh_v_conv.conv.weight.copy_(gh_v.to(self.gh_v_conv.conv.weight.device).to(self.gh_v_conv.conv.weight.dtype))

# 冻结所有小波卷积层的权重（小波核是固定的数学变换）

self.h_conv.requires_grad_(False)

self.g_conv.requires_grad_(False)

self.hh_conv.requires_grad_(False)

self.gh_conv.requires_grad_(False)

self.h_v_conv.requires_grad_(False)

self.g_v_conv.requires_grad_(False)

self.hh_v_conv.requires_grad_(False)

self.gh_v_conv.requires_grad_(False)

  

def forward(self, x):


assert x.dim() == 5, f"输入必须是 5D 张量 [B,C,T,H,W]，当前维度: {x.dim()}"

b = x.shape[0] # batch size

c = x.shape[1] # 通道数

# 将 [B, C, T, H, W] 重排为 [(B*C), 1, T, H, W]，便于逐通道处理

x = rearrange(x, "b c t h w -> (b c) 1 t h w")

# 提出batch size
n_dim = x.shape[0] 

outputs = []

# 对每个通道分别应用 8 种小波变换

for i in range(n_dim):

# 切片而不是索引来保留通道维度
# 取第 i 个通道 [1, 1, T, H, W]
y = x[i: i+1] 

# 应用 8 个不同的小波滤波器

outputs.append(self.h_conv(y)) # LLL 低频

outputs.append(self.g_conv(y)) # LLH 垂直边缘

outputs.append(self.hh_conv(y)) # LHL 水平边缘

outputs.append(self.gh_conv(y)) # LHH 对角线

outputs.append(self.h_v_conv(y)) # HLL 时间变化

outputs.append(self.g_v_conv(y)) # HLH

outputs.append(self.hh_v_conv(y)) # HHL

outputs.append(self.gh_v_conv(y)) # HHH 高频细节

# 拼接所有输出 [(B*C*8), 1, T/2, H/2, W/2]

outputs = torch.cat(outputs, dim=0)

# 重排回 [B, 8*C, T/2, H/2, W/2]

# 重排让 RGB 通道的 8 个系数分量按小波顺序堆叠

outputs = rearrange(outputs, "(b k c) 1 t h w -> b (c k) t h w", b=b, k=c)

return outputs
```

---

<font color="#2ecc71">✅ 已格式化</font>
