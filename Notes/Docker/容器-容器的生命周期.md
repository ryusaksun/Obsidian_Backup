这幅图展示了 Docker 容器的生命周期。理解这些状态对于运维排查问题非常重要，因为它描述了一个容器从"出生"到"消亡"的全过程。

我们可以把容器想象成一个"员工"，这五个状态就是他入职、工作到离职的五个阶段。我结合你提供的图片 来详细拆解一下：

---

## Created (已创建) —— "入职手续办完了，但还没来上班"

- 状态描述： 容器已经被创建出来了，Docker 已经给它分配了身份证号（Container ID），并且把它的办公桌（文件系统层）都准备好了。

- 关键点： 进程还没启动。此时 CPU 和内存里并没有它的身影。

- 触发命令： `docker create`

- 应用场景： 当你需要先准备好一批容器配置，但想稍后再统一启动时使用。

---

## Running (运行中) —— "正在工位上干活"

- 状态描述： 这是容器最核心的状态。容器里的主进程（PID 1）正在 CPU 上运行。

- 关键点： 此时它正在消耗系统的 CPU 和内存资源。

- 触发命令： `docker start`（把已创建的启动）或 `docker run`（创建并启动）。

- 注意： `docker run` 其实是个组合拳，等于 `docker create` + `docker start`。

---

## Paused (已暂停) —— "被施了定身术"

- 状态描述： 这就是很多新手容易混淆的地方。容器并没有死，只是被"冻结"了。

- 技术原理： 利用 cgroups 的 freezer 子系统挂起进程。

- 关键区别（重点）：

    - Paused： 进程还在内存里，只是不给它分配 CPU 时间片了。就像按下了电影的暂停键，画面定格，恢复速度极快。

    - Stopped： 进程被杀死了，内存也被释放了。

- 触发命令： `docker pause`

- 应用场景： 想要临时腾出 CPU 给别的任务，但又不想丢失当前应用运行的上下文（比如不想断开内存里的临时数据）。

---

## Stopped (已停止) —— "下班回家" 或 "被开除"

- 状态描述： 容器里的进程已经结束了，CPU 和内存资源被完全释放。但是，容器的"办公桌"（读写层的数据）还在，只是人走了。

- 触发命令： `docker stop`

- 优雅退出 vs 强制杀死： 图片里提到了两个非常重要的信号机制：

    1. 优雅退出 : 当你执行 `stop` 时，Docker 会先礼后兵。它先发一个 `SIGTERM` 信号，意思是"请收拾一下东西，我们要关门了"。容器默认有 10 秒钟时间保存数据、断开连接。

    2. 强制杀死 : 如果 10 秒后容器还在赖着不走，Docker 就会发送 `SIGKILL` 信号。这就相当于直接拔电源，可能会导致数据丢失。

---

## Deleted (已删除) —— "离职，工位清空"

- 状态描述： 这是彻底的毁灭。

- 关键点： 容器的元数据（ID、配置）和读写层（你在容器里修改过的所有文件）都会被从硬盘上物理抹除。

- 触发命令： `docker rm`

- 后果： 一旦删除，除非你挂载了外部的数据卷，否则你在容器里写的所有数据都找不回来了。

---

**核心记忆法：**

- Paused = 占内存，不占 CPU（定身）。

- Stopped = 不占内存，不占 CPU，但硬盘上的数据还在（睡觉）。

- Deleted = 连硬盘上的数据都没了（火化）。

---

**<font color="#2ecc71">✅ 已格式化</font>**
