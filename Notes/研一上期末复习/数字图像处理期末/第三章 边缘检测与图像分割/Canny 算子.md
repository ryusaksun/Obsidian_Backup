Canny 算子（Canny Edge Detector）被公认为<font color="#f79646">边缘检测领域的"黄金标准"</font>。它由 John F. Canny 在 1986 年提出，不是一个简单的数学公式，而是一个精心设计的多阶段算法。它的核心目标是：<font color="#f79646">找到尽可能多的真实边缘，同时尽可能少地误报噪声，并且边缘定位要极其精准</font>。

与 Sobel 等简单算子相比，Canny 算子最大的特点是"细"（单像素宽）且"准"（去噪能力强）。

整个算法流程可以分为五个关键步骤：

## 第一步：高斯平滑（去噪）

边缘检测对噪声非常敏感。如果直接算梯度，图像上的噪点（比如雪花点）会被误认为是边缘。

- 做法：使用高斯滤波器（Gaussian Filter）对图像进行模糊处理。
- 目的：<font color="#f79646">平滑掉细小的噪点，防止它们干扰后续的检测</font>。

## 第二步：计算梯度幅值和方向

这一步通常使用 Sobel 算子（或其他梯度算子）来计算图像中每个像素的亮度变化情况。

- 计算内容：

    - 梯度幅值：表示边缘有多强（越亮越强）。
    - 梯度方向 $\theta$：表示边缘朝向哪里（如水平、垂直、45 度等）。

- 结果：<font color="#f79646">得到一张"粗糙"的边缘图，这时候边缘还很宽，不够精细</font>。

## 第三步：非极大值抑制（NMS, Non-Maximum Suppression）

这一步是 Canny 算子的精华所在，<font color="#f79646">目的是把边缘变细</font>（瘦身）。

- 原理：对于每一个被认为是边缘的像素，去看看<font color="#f79646">它在梯度方向上的两个邻居</font>（前一个和后一个像素）。

    - <font color="#f79646">如果当前像素的梯度值是这三个里最大的，那就保留它（说明它是边缘的"山峰"）</font>。
    - <font color="#f79646">如果它不是最大的，说明它只是边缘的"山坡"，那就把它抑制（置为 0）</font>。

- 效果：原本宽宽的边缘线条，瞬间变成了只有 1 个像素宽的细线。

## 第四步：<font color="#f79646">双阈值检测</font>（Double Thresholding）

经过上一步，虽然边缘细了，但可能还有很多<font color="#f79646">微弱的假边缘</font>（由噪声引起）。Canny 设定了两个阈值：高阈值（High）和低阈值（Low）。

- 强边缘：梯度值 > 高阈值。这些肯定是真边缘，直接保留（标记为强）。
- 弱边缘：低阈值 < 梯度值 < 高阈值。这些可能是真边缘，也可能是噪声，待定（标记为弱）。
- 非边缘：梯度值 < 低阈值。这些肯定是噪声，直接扔掉（置为 0）。

## 第五步：<font color="#f79646">滞后边界跟踪</font>（Edge Tracking by Hysteresis）

最后一步是<font color="#f79646">处理那些"待定"的弱边缘</font>。

- 逻辑：

    - 如果一个弱边缘像素连接到了强边缘像素上，说明它也是真边缘的一部分，那就把它"转正"保留下来。
    - 如果一个弱边缘像素孤立无援，周围没有强边缘，那它大概率是噪声，直接扔掉。

- 结果：最终输出一张干净、连续、单像素宽的二值化边缘图。

总结：

Canny 算子之所以强，是因为它不仅能算梯度（像 Sobel 那样），还懂得去噪（高斯滤波）、瘦身（非极大值抑制）和挑剔（双阈值+滞后跟踪），因此它的检测结果最清晰、最符合人眼视觉。

---

**<font color="#2ecc71">✅ 已格式化</font>**
