`>` 和 `>>` 都是 Linux 中的输出重定向符号，它们的作用是将命令在屏幕上显示的内容，"转存"到文件中。

两者的核心区别在于：对待旧文件的态度。

## 1. 核心区别 (一句话记住)

| 符号 | 名称 | 动作逻辑 | 形象比喻 |
|---|---|---|---|
| `>` | 覆盖重定向 | 先清空，再写入 | 像"格式化"后再写，旧数据全丢 |
| `>>` | 追加重定向 | 不清空，接在后面写 | 像"记日记"，接着昨天的写 |

## 2. 详细用法演示

### `>` (覆盖模式)

如果目标文件不存在，它会新建；如果存在，它会直接清空原有内容。

```bash
echo "Hello" > file.txt
# 此时 file.txt 内容是：Hello

echo "World" > file.txt
# 此时 file.txt 内容是：World ("Hello" 被删除掉了）
```

- 危险场景：千万不要随手写 `cat > 重要配置文件.conf`，除非你确定要重写它。

### `>>` (追加模式)

如果目标文件不存在，它会新建；如果存在，它会在文件末尾继续添加。

```bash
echo "Hello" >> file.txt
# 此时 file.txt 内容是：Hello

echo "World" >> file.txt
# 此时 file.txt 内容是：
# Hello
# World
```

- 最佳场景：用来记日志，比如 `python main.py >> run.log`，这样每次运行的日志都会保存下来。

## 3. 进阶：标准错误重定向 (2> 和 2>>)

默认情况下，`>` 和 `>>` 只重定向"正确的信息"（标准输出）。如果命令报错了，错误信息还是会打印在屏幕上。

- 把错误也写进文件：

```bash
# 2 代表标准错误 (Standard Error)
ls 不存在的文件 2> error.log
```

- 把正确和错误都写进同一个文件 (最常用)：

```bash
# &> 代表混合输出
command &> all.log

# 或者老式写法
command > all.log 2>&1
```

## 总结

- 想**保存**新内容但**不删除**旧内容：用 `>>`。
- 想**完全替换**旧文件：用 `>`。
- **清空一个文件最快的方法**：`> huge_log_file.log` (什么都不写，直接覆盖为空）。

---

**<font color="#2ecc71">✅ 已格式化</font>**
